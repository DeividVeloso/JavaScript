{"version":3,"sources":["../../app-es6/services/ProxyFactory.js"],"names":["ProxyFactory","objeto","props","acao","Proxy","get","target","prop","receiver","includes","_ehFuncao","console","log","retorno","Reflect","apply","arguments","set","value","func","Function"],"mappings":";;;;;;;;IAAMA,Y;;;;;;;;AACF;AACA;AACA;AACA;+BACcC,M,EAAQC,K,EAAOC,I,EAAK;;AAE7B,mBAAQ,IAAIC,KAAJ,CAAUH,MAAV,EAAiB;AAElBI,mBAFkB,eAEdC,MAFc,EAEPC,IAFO,EAEDC,QAFC,EAEQ;;AAEtB,wBAAGN,MAAMO,QAAN,CAAeF,IAAf,KAAwBP,aAAaU,SAAb,CAAuBJ,OAAOC,IAAP,CAAvB,CAA3B,EAAgE;;AAE5D,+BAAO,YAAU;;AAEb;AACAI,oCAAQC,GAAR,gCAAsCL,IAAtC;;AAEA;AACA;AACA;AACA;AACA,gCAAIM,UAAUC,QAAQC,KAAR,CAAcT,OAAOC,IAAP,CAAd,EAA2BD,MAA3B,EAAkCU,SAAlC,CAAd;;AAEA;AACAb,iCAAKG,MAAL;;AAEA;AACA,mCAAOO,OAAP;AACH,yBAhBD;AAiBH;AACD,2BAAOC,QAAQT,GAAR,CAAYC,MAAZ,EAAoBC,IAApB,EAA0BC,QAA1B,CAAP;AACH,iBAzBiB;AA2BlBS,mBA3BkB,eA2BdX,MA3Bc,EA2BPC,IA3BO,EA2BFW,KA3BE,EA2BIV,QA3BJ,EA2Ba;AAC3B,wBAAIK,UAAUC,QAAQG,GAAR,CAAYX,MAAZ,EAAmBC,IAAnB,EAAwBW,KAAxB,EAA8BV,QAA9B,CAAd;AACA,wBAAGN,MAAMO,QAAN,CAAeF,IAAf,CAAH,EAAwB;AACpB;AACCJ,6BAAKG,MAAL;AACJ;AACD;AACF,2BAAOO,OAAP;AACD;AAnCiB,aAAjB,CAAR;AAqCJ;;;kCAEgBM,I,EAAK;AAClB,mBAAO,QAAOA,IAAP,yCAAOA,IAAP,cAAuBC,QAAvB,yCAAuBA,QAAvB,EAAP;AACH","file":"ProxyFactory.js","sourcesContent":["class ProxyFactory {\r\n    //criando um método estatico para não ter que ficar instanciando a classe\r\n    //Recebe o objeto que eu quero criar o proxy (ListaNegociacoes)\r\n    //Recebe as propriedades que eu quero observar (['adiciona', 'esvazia'])\r\n    //Recebe a ação que eu quero executar (self._negociacoesView.update)\r\n    static create(objeto, props, acao){\r\n\r\n         return  new Proxy(objeto,{\r\n\r\n                get(target,prop, receiver){\r\n                   \r\n                    if(props.includes(prop) && ProxyFactory._ehFuncao(target[prop])){\r\n\r\n                        return function(){\r\n\r\n                            //Aqui é minha funcao e o REFLECT apply Substitui o Adiciona por ela.\r\n                            console.log(`interceptando o método ${prop}`);\r\n\r\n                            //Chamando o método dessa função\r\n                            //target[prop] = minhas propriedade do meu objeto original Proxy(ListaNegociacoes)\r\n                            //target = contexto - this ele mesmo\r\n                            //arguments - array de argumentos que estou passando no método adiciona(new Negociacao(new Date(),1,100))\r\n                            let retorno = Reflect.apply(target[prop],target,arguments);\r\n\r\n                            //Só posso chamar a atualização da view depois do que aplicar o target(model Negociacao)\r\n                            acao(target);\r\n\r\n                            //Retornando o apply da função, que é quando troca os dados da acao passada\r\n                            return retorno;\r\n                        }\r\n                    }\r\n                    return Reflect.get(target, prop, receiver);\r\n                },\r\n\r\n                set(target,prop,value,receiver){\r\n                    let retorno = Reflect.set(target,prop,value,receiver);\r\n                    if(props.includes(prop)){\r\n                        //executa o interceptador(this.mensagem.update(prop.value))\r\n                         acao(target);\r\n                    }\r\n                    //Altera a propriedade\r\n                  return retorno;\r\n                }\r\n        });\r\n    }\r\n\r\n    static _ehFuncao(func){\r\n        return typeof(func) == typeof(Function);\r\n    }\r\n}"]}